/* Generated by Nelua 0.2.0-dev */
/* Compile command: gcc -x c "riscvm.c" -x none -pipe -fwrapv -fno-strict-aliasing -g -lm -o "riscvm" */
/* Compile hash: 3yRF316SvDmqYnDkveN73j7PiY2f */
/* ------------------------------ DIRECTIVES -------------------------------- */
#define NELUA_NIL (nlniltype){}
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
/* Macro used to force inlining a function. */
#ifdef __GNUC__
#define NELUA_INLINE __attribute__((always_inline)) inline
#elif defined(_MSC_VER)
#define NELUA_INLINE __forceinline
#elif __STDC_VERSION__ >= 199901L
#define NELUA_INLINE inline
#else
#define NELUA_INLINE
#endif
#include <stddef.h>
#include <stdlib.h>
/* Macro used to import/export extern C functions. */
#ifdef __cplusplus
#define NELUA_EXTERN extern "C"
#else
#define NELUA_EXTERN extern
#endif
/* Macro used to generate traceback on aborts when sanitizing. */
#if defined(__clang__) && defined(__has_feature)
#if __has_feature(undefined_behavior_sanitizer)
#define NELUA_UBSAN_UNREACHABLE __builtin_unreachable
#endif
#elif defined(__gnu_linux__) && defined(__GNUC__) && __GNUC__ >= 5
NELUA_EXTERN void __ubsan_handle_builtin_unreachable( void* ) __attribute__( ( weak ) );
#define NELUA_UBSAN_UNREACHABLE() {if(&__ubsan_handle_builtin_unreachable) __builtin_unreachable();}
#endif
#ifndef NELUA_UBSAN_UNREACHABLE
#define NELUA_UBSAN_UNREACHABLE()
#endif
/* Macro used to specify a function that never returns. */
#if __STDC_VERSION__ >= 201112L
#define NELUA_NORETURN _Noreturn
#elif defined(__GNUC__)
#define NELUA_NORETURN __attribute__((noreturn))
#elif defined(_MSC_VER)
#define NELUA_NORETURN __declspec(noreturn)
#else
#define NELUA_NORETURN
#endif
/* Macro used sign that a type punning cast may alias (related to strict aliasing). */
#ifdef __GNUC__
#define NELUA_MAYALIAS __attribute__((may_alias))
#else
#define NELUA_MAYALIAS
#endif
/* Macro used for branch prediction. */
#if defined(__GNUC__) || defined(__clang__)
#define NELUA_LIKELY(x) __builtin_expect(x, 1)
#else
#define NELUA_LIKELY(x) (x)
#endif
/* Macro used for branch prediction. */
#if defined(__GNUC__) || defined(__clang__)
#define NELUA_UNLIKELY(x) __builtin_expect(x, 0)
#else
#define NELUA_UNLIKELY(x) (x)
#endif
/* Macro used to force not inlining a function. */
#ifdef __GNUC__
#define NELUA_NOINLINE __attribute__((noinline))
#elif defined(_MSC_VER)
#define NELUA_NOINLINE __declspec(noinline)
#else
#define NELUA_NOINLINE
#endif
/* ------------------------------ DECLARATIONS ------------------------------ */
typedef struct nlniltype
{} nlniltype;
typedef struct nlniltype nltype;
typedef struct machine_Machine machine_Machine;
typedef machine_Machine* machine_Machine_ptr;
struct machine_Machine
{
    bool running;
    int64_t pc;
    uint64_t regs[ 32 ];
    uint8_t memory[ 134217728 ];
    int64_t exitcode;
};
typedef struct nlstring nlstring;
typedef uint8_t* nluint8_arr0_ptr;
struct nlstring
{
    nluint8_arr0_ptr data;
    uintptr_t size;
};
static void machine_Machine_loadfile( machine_Machine_ptr self, nlstring filename );
typedef FILE* FILE_ptr;
static NELUA_INLINE char* nelua_string2cstring( nlstring s );
static NELUA_INLINE void nelua_write_stderr( const char* msg, uintptr_t len, bool flush );
static NELUA_NORETURN void nelua_abort( void );
static NELUA_NORETURN void nelua_panic_string( nlstring s );
typedef struct NELUA_MAYALIAS nluint8_arr134217728
{
    uint8_t v[ 134217728 ];
} nluint8_arr134217728;
typedef union NELUA_MAYALIAS nluint8_arr134217728_cast
{
    nluint8_arr134217728 a; uint8_t p[ 134217728 ];
} nluint8_arr134217728_cast;
typedef struct NELUA_MAYALIAS nluint64_arr32
{
    uint64_t v[ 32 ];
} nluint64_arr32;
typedef union NELUA_MAYALIAS nluint64_arr32_cast
{
    nluint64_arr32 a; uint64_t p[ 32 ];
} nluint64_arr32_cast;
static NELUA_INLINE uint32_t machine_Machine_fetch( machine_Machine_ptr self );
typedef uint32_t* nluint32_ptr;
static NELUA_INLINE int8_t machine_Machine_read_1( machine_Machine_ptr self, nlniltype T, uint64_t addr );
static NELUA_INLINE int16_t machine_Machine_read_2( machine_Machine_ptr self, nlniltype T, uint64_t addr );
typedef uint16_t* nluint16_ptr;
static NELUA_INLINE int32_t machine_Machine_read_3( machine_Machine_ptr self, nlniltype T, uint64_t addr );
static NELUA_INLINE int64_t machine_Machine_read_4( machine_Machine_ptr self, nlniltype T, uint64_t addr );
typedef uint64_t* nluint64_ptr;
static NELUA_INLINE uint8_t machine_Machine_read_5( machine_Machine_ptr self, nlniltype T, uint64_t addr );
static NELUA_INLINE uint16_t machine_Machine_read_6( machine_Machine_ptr self, nlniltype T, uint64_t addr );
static NELUA_INLINE uint32_t machine_Machine_read_7( machine_Machine_ptr self, nlniltype T, uint64_t addr );
static NELUA_INLINE void* machine_Machine_getptr( machine_Machine_ptr self, uint64_t addr );
static NELUA_INLINE void machine_Machine_write_1( machine_Machine_ptr self, uint64_t addr, uint8_t val );
static NELUA_INLINE void machine_Machine_write_2( machine_Machine_ptr self, uint64_t addr, uint16_t val );
static NELUA_INLINE void machine_Machine_write_3( machine_Machine_ptr self, uint64_t addr, uint32_t val );
static NELUA_INLINE void machine_Machine_write_4( machine_Machine_ptr self, uint64_t addr, uint64_t val );
static uint64_t machine_Machine_handle_syscall( machine_Machine_ptr self, uint64_t code );
static void nelua_print_1( char* a1 );
static void nelua_print_2( int64_t a1 );
static NELUA_INLINE void machine_Machine_execute( machine_Machine_ptr self, uint32_t inst );
static NELUA_INLINE int64_t nelua_shl_nlint64( int64_t a, int64_t b );
static NELUA_INLINE int64_t nelua_shr_nlint64( int64_t a, int64_t b );
static NELUA_INLINE int64_t nelua_asr_nlint64( int64_t a, int64_t b );
static NELUA_INLINE __int128 nelua_shr_nlint128( __int128 a, __int128 b );
static NELUA_NOINLINE void machine_Machine_run( machine_Machine_ptr self );
static int nelua_argc;
typedef char** nlcstring_arr0_ptr;
static nlcstring_arr0_ptr nelua_argv;
static void nelua_print_3( nlstring a1 );
static char* riscvm_filename;
static machine_Machine riscvm_machine;
static NELUA_INLINE nlstring nelua_cstring2string( const char* s );
static int nelua_main( int argc, char** argv );
/* ------------------------------ DEFINITIONS ------------------------------- */
char* nelua_string2cstring( nlstring s )
{
    return ( s.size == 0 ) ? ( char* )"" : ( char* )s.data;
}
void nelua_write_stderr( const char* msg, uintptr_t len, bool flush )
{
    if( len > 0 && msg )
    {
        fwrite( msg, 1, len, stderr );
    }
    if( flush )
    {
        fwrite( "\n", 1, 1, stderr );
        fflush( stderr );
    }
}
void nelua_abort( void )
{
    NELUA_UBSAN_UNREACHABLE();
    abort();
}
void nelua_panic_string( nlstring s )
{
    if( s.size > 0 )
    {
        nelua_write_stderr( ( const char* )s.data, s.size, true );
    }
    nelua_abort();
}
void machine_Machine_loadfile( machine_Machine_ptr self, nlstring filename )
{
    FILE_ptr fp = fopen( nelua_string2cstring( filename ), "rb" );
    if( ( !( fp != NULL ) ) )
    {
        nelua_panic_string( ( ( nlstring )
        {
            ( uint8_t* )"failed to open file", 19
        } ) );
    }
    fseek( fp, 0, SEEK_END );
    long size = ftell( fp );
    fseek( fp, 0, SEEK_SET );
    fread( ( void* )( &( ( ( nluint8_arr134217728_cast* )&self->memory )->a ).v[ 4096 ] ), ( size_t )size, 1U, fp );
    fclose( fp );
    ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ 2 ] = 134217728U;
    self->pc = 4096;
}
uint32_t machine_Machine_fetch( machine_Machine_ptr self )
{
    return ( *( nluint32_ptr )( &( ( ( nluint8_arr134217728_cast* )&self->memory )->a ).v[ self->pc ] ) );
}
int8_t machine_Machine_read_1( machine_Machine_ptr self, nlniltype T, uint64_t addr )
{
    return ( int8_t )( *( &( ( ( nluint8_arr134217728_cast* )&self->memory )->a ).v[ addr ] ) );
}
int16_t machine_Machine_read_2( machine_Machine_ptr self, nlniltype T, uint64_t addr )
{
    return ( int16_t )( *( nluint16_ptr )( &( ( ( nluint8_arr134217728_cast* )&self->memory )->a ).v[ addr ] ) );
}
int32_t machine_Machine_read_3( machine_Machine_ptr self, nlniltype T, uint64_t addr )
{
    return ( int32_t )( *( nluint32_ptr )( &( ( ( nluint8_arr134217728_cast* )&self->memory )->a ).v[ addr ] ) );
}
int64_t machine_Machine_read_4( machine_Machine_ptr self, nlniltype T, uint64_t addr )
{
    return ( int64_t )( *( nluint64_ptr )( &( ( ( nluint8_arr134217728_cast* )&self->memory )->a ).v[ addr ] ) );
}
uint8_t machine_Machine_read_5( machine_Machine_ptr self, nlniltype T, uint64_t addr )
{
    return ( *( &( ( ( nluint8_arr134217728_cast* )&self->memory )->a ).v[ addr ] ) );
}
uint16_t machine_Machine_read_6( machine_Machine_ptr self, nlniltype T, uint64_t addr )
{
    return ( *( nluint16_ptr )( &( ( ( nluint8_arr134217728_cast* )&self->memory )->a ).v[ addr ] ) );
}
uint32_t machine_Machine_read_7( machine_Machine_ptr self, nlniltype T, uint64_t addr )
{
    return ( *( nluint32_ptr )( &( ( ( nluint8_arr134217728_cast* )&self->memory )->a ).v[ addr ] ) );
}
void* machine_Machine_getptr( machine_Machine_ptr self, uint64_t addr )
{
    return ( void* )( &( ( ( nluint8_arr134217728_cast* )&self->memory )->a ).v[ addr ] );
}
void machine_Machine_write_1( machine_Machine_ptr self, uint64_t addr, uint8_t val )
{
    ( *( &( ( ( nluint8_arr134217728_cast* )&self->memory )->a ).v[ addr ] ) ) = val;
}
void machine_Machine_write_2( machine_Machine_ptr self, uint64_t addr, uint16_t val )
{
    ( *( nluint16_ptr )( &( ( ( nluint8_arr134217728_cast* )&self->memory )->a ).v[ addr ] ) ) = val;
}
void machine_Machine_write_3( machine_Machine_ptr self, uint64_t addr, uint32_t val )
{
    ( *( nluint32_ptr )( &( ( ( nluint8_arr134217728_cast* )&self->memory )->a ).v[ addr ] ) ) = val;
}
void machine_Machine_write_4( machine_Machine_ptr self, uint64_t addr, uint64_t val )
{
    ( *( nluint64_ptr )( &( ( ( nluint8_arr134217728_cast* )&self->memory )->a ).v[ addr ] ) ) = val;
}
void nelua_print_1( char* a1 )
{
    fputs( a1 != NULL ? a1 : "(null cstring)", stdout );
    fputs( "\n", stdout );
    fflush( stdout );
}
void nelua_print_2( int64_t a1 )
{
    fprintf( stdout, "%lli", ( long long )a1 );
    fputs( "\n", stdout );
    fflush( stdout );
}

NELUA_INLINE uint32_t syscall_0_stub( uint32_t id )
{
    register void* a1 asm( "r10" );
    void* a2;
    register void* a3 asm( "r8" );
    register void* a4 asm( "r9" );

    void* unused_output;
    register void* unused_output2 asm( "r11" );

    uint32_t status;
    asm volatile( "syscall\n"
                  : "=a"( status ), "=r"( a1 ), "=d"( a2 ), "=r"( a3 ), "=r"( a4 ), "=c"( unused_output ), "=r"( unused_output2 )
                  : "a"( id )
                  : "memory", "cc" );
    return status;
}

NELUA_INLINE uint32_t syscall_1_stub( uint32_t id, uint64_t _1 )
{
    register uint64_t a1 asm( "r10" ) = _1;
    void* a2;
    register void* a3 asm( "r8" );
    register void* a4 asm( "r9" );

    void* unused_output;
    register void* unused_output2 asm( "r11" );

    uint32_t status;
    asm volatile( "syscall\n"
                  : "=a"( status ), "=r"( a1 ), "=d"( a2 ), "=r"( a3 ), "=r"( a4 ), "=c"( unused_output ), "=r"( unused_output2 )
                  : "a"( id ), "r"( a1 )
                  : "memory", "cc" );
    return status;
}

NELUA_INLINE uint32_t syscall_2_stub( uint32_t id, uint64_t _1, uint64_t _2 )
{
    register uint64_t a1 asm( "r10" ) = _1;
    register void* a3 asm( "r8" );
    register void* a4 asm( "r9" );

    void* unused_output;
    register void* unused_output2 asm( "r11" );

    uint32_t status;
    asm volatile( "syscall\n"
                  : "=a"( status ), "=r"( a1 ), "=d"( _2 ), "=r"( a3 ), "=r"( a4 ), "=c"( unused_output ), "=r"( unused_output2 )
                  : "a"( id ), "r"( a1 ), "d"( _2 )
                  : "memory", "cc" );
    return status;
}

NELUA_INLINE uint32_t syscall_3_stub( uint32_t id, uint64_t _1, uint64_t _2, uint64_t _3 )
{
    register uint64_t a1 asm( "r10" ) = _1;
    register uint64_t a3 asm( "r8" ) = _3;
    register void* a4 asm( "r9" );

    void* unused_output;
    register void* unused_output2 asm( "r11" );

    uint32_t status;
    asm volatile( "syscall\n"
                  : "=a"( status ), "=r"( a1 ), "=d"( _2 ), "=r"( a3 ), "=r"( a4 ), "=c"( unused_output ), "=r"( unused_output2 )
                  : "a"( id ), "r"( a1 ), "d"( _2 ), "r"( a3 )
                  : "memory", "cc" );
    return status;
}

NELUA_INLINE uint32_t syscall_4_stub( uint32_t id, uint64_t _1, uint64_t _2, uint64_t _3, uint64_t _4 )
{
    register uint64_t a1 asm( "r10" ) = _1;
    register uint64_t a3 asm( "r8" ) = _3;
    register uint64_t a4 asm( "r9" ) = _4;

    void* unused_output;
    register void* unused_output2 asm( "r11" );

    uint32_t status;
    asm volatile( "syscall\n"
                  : "=a"( status ), "=r"( a1 ), "=d"( _2 ), "=r"( a3 ), "=r"( a4 ), "=c"( unused_output ), "=r"( unused_output2 )
                  : "a"( id ), "r"( a1 ), "d"( _2 ), "r"( a3 ), "r"( a4 )
                  : "memory", "cc" );
    return status;
}

NELUA_INLINE uint32_t syscall_5_stub( uint32_t id, uint64_t _1, uint64_t _2, uint64_t _3, uint64_t _4, uint64_t _5 )
{
    register uint64_t a1 asm( "r10" ) = _1;
    register uint64_t a3 asm( "r8" ) = _3;
    register uint64_t a4 asm( "r9" ) = _4;

    void* unused_output;
    register void* unused_output2 asm( "r11" );

    uint32_t status;
    asm volatile( "sub $48, %%rsp\n"
                  "movq %[a5], 40(%%rsp)\n"
                  "syscall\n"
                  "add $48, %%rsp"
                  : "=a"( status ), "=r"( a1 ), "=d"( _2 ), "=r"( a3 ), "=r"( a4 ), "=c"( unused_output ), "=r"( unused_output2 )
                  : "a"( id ), "r"( a1 ), "d"( _2 ), "r"( a3 ), "r"( a4 ), [ a5 ] "re"( ( void* )( _5 ) )
                  : "cc" );
    return status;
}

NELUA_INLINE uint32_t syscall_6_stub( uint32_t id, uint64_t _1, uint64_t _2, uint64_t _3, uint64_t _4, uint64_t _5, uint64_t _6 )
{
    register uint64_t a1 asm( "r10" ) = _1;
    register uint64_t a3 asm( "r8" ) = _3;
    register uint64_t a4 asm( "r9" ) = _4;

    void* unused_output;
    register uint64_t unused_output2 asm( "r11" );

    uint32_t status;
    asm volatile(
        "sub $64, %%rsp\n"
        "movq %[a5], 40(%%rsp)\n"
        "movq %[a6], 48(%%rsp)\n"
        "syscall\n"
        "add $64, %%rsp"
        : "=a"( status ), "=r"( a1 ), "=d"( _2 ), "=r"( a3 ), "=r"( a4 ), "=c"( unused_output ), "=r"( unused_output2 )
        : "a"( id ), "r"( a1 ), "d"( _2 ), "r"( a3 ), "r"( a4 ), [ a5 ] "re"( _5 ), [ a6 ] "re"( _6 )
        : "memory", "cc"
        );
    return status;
}

NELUA_INLINE uint32_t syscall_7_stub( uint32_t id, uint64_t _1, uint64_t _2, uint64_t _3, uint64_t _4, uint64_t _5, uint64_t _6, uint64_t _7 )
{
    register uint64_t a1 asm( "r10" ) = _1;
    register uint64_t a3 asm( "r8" ) = _3;
    register uint64_t a4 asm( "r9" ) = _4;

    void* unused_output;
    register uint64_t unused_output2 asm( "r11" );

    uint32_t status;
    asm volatile( "sub $64, %%rsp\n"
                  "movq %[a5], 40(%%rsp)\n"
                  "movq %[a6], 48(%%rsp)\n"
                  "movq %[a7], 56(%%rsp)\n"
                  "syscall\n"
                  "add $64, %%rsp"
                  : "=a"( status ), "=r"( a1 ), "=d"( _2 ), "=r"( a3 ), "=r"( a4 ), "=c"( unused_output ), "=r"( unused_output2 )
                  : "a"( id ),
                  "r"( a1 ),
                  "d"( _2 ),
                  "r"( a3 ),
                  "r"( a4 ),
                  [ a5 ] "re"( _5 ),
                  [ a6 ] "re"( _6 ),
                  [ a7 ] "re"( _7 )
                  : "memory", "cc" );
    return status;
}

NELUA_INLINE uint32_t syscall_8_stub( uint32_t id, uint64_t _1, uint64_t _2, uint64_t _3, uint64_t _4, uint64_t _5, uint64_t _6, uint64_t _7, uint64_t _8 )
{
    register uint64_t a1 asm( "r10" ) = _1;
    register uint64_t a3 asm( "r8" ) = _3;
    register uint64_t a4 asm( "r9" ) = _4;

    void* unused_output;
    register uint64_t unused_output2 asm( "r11" );

    uint32_t status;
    asm volatile( "sub $80, %%rsp\n"
                  "movq %[a5], 40(%%rsp)\n"
                  "movq %[a6], 48(%%rsp)\n"
                  "movq %[a7], 56(%%rsp)\n"
                  "movq %[a8], 64(%%rsp)\n"
                  "syscall\n"
                  "add $80, %%rsp"
                  : "=a"( status ), "=r"( a1 ), "=d"( _2 ), "=r"( a3 ), "=r"( a4 ), "=c"( unused_output ), "=r"( unused_output2 )
                  : "a"( id ),
                  "r"( a1 ),
                  "d"( _2 ),
                  "r"( a3 ),
                  "r"( a4 ),
                  [ a5 ] "re"( _5 ),
                  [ a6 ] "re"( _6 ),
                  [ a7 ] "re"( _7 ),
                  [ a8 ] "re"( _8 )
                  : "memory", "cc" );
    return status;
}

NELUA_INLINE uint32_t syscall_9_stub( uint32_t id, uint64_t _1, uint64_t _2, uint64_t _3, uint64_t _4, uint64_t _5, uint64_t _6, uint64_t _7, uint64_t _8, uint64_t _9 )
{
    register uint64_t a1 asm( "r10" ) = _1;
    register uint64_t a3 asm( "r8" ) = _3;
    register uint64_t a4 asm( "r9" ) = _4;

    void* unused_output;
    register uint64_t unused_output2 asm( "r11" );

    uint32_t status;
    asm volatile( "sub $80, %%rsp\n"
                  "movq %[a5], 40(%%rsp)\n"
                  "movq %[a6], 48(%%rsp)\n"
                  "movq %[a7], 56(%%rsp)\n"
                  "movq %[a8], 64(%%rsp)\n"
                  "movq %[a9], 72(%%rsp)\n"
                  "syscall\n"
                  "add $80, %%rsp"
                  : "=a"( status ), "=r"( a1 ), "=d"( _2 ), "=r"( a3 ), "=r"( a4 ), "=c"( unused_output ), "=r"( unused_output2 )
                  : "a"( id ),
                  "r"( a1 ),
                  "d"( _2 ),
                  "r"( a3 ),
                  "r"( a4 ),
                  [ a5 ] "re"( _5 ),
                  [ a6 ] "re"( _6 ),
                  [ a7 ] "re"( _7 ),
                  [ a8 ] "re"( _8 ),
                  [ a9 ] "re"( _9 )
                  : "memory", "cc" );
    return status;
}

NELUA_INLINE uint32_t syscall_10_stub( uint32_t id, uint64_t _1, uint64_t _2, uint64_t _3, uint64_t _4, uint64_t _5, uint64_t _6, uint64_t _7, uint64_t _8, uint64_t _9, uint64_t _10 )
{
    register uint64_t a1 asm( "r10" ) = _1;
    register uint64_t a3 asm( "r8" ) = _3;
    register uint64_t a4 asm( "r9" ) = _4;

    void* unused_output;
    register uint64_t unused_output2 asm( "r11" );

    uint32_t status;
    asm volatile( "sub $96, %%rsp\n"
                  "movq %[a5], 40(%%rsp)\n"
                  "movq %[a6], 48(%%rsp)\n"
                  "movq %[a7], 56(%%rsp)\n"
                  "movq %[a8], 64(%%rsp)\n"
                  "movq %[a9], 72(%%rsp)\n"
                  "movq %[a10], 80(%%rsp)\n"
                  "syscall\n"
                  "add $96, %%rsp"
                  : "=a"( status ), "=r"( a1 ), "=d"( _2 ), "=r"( a3 ), "=r"( a4 ), "=c"( unused_output ), "=r"( unused_output2 )
                  : "a"( id ),
                  "r"( a1 ),
                  "d"( _2 ),
                  "r"( a3 ),
                  "r"( a4 ),
                  [ a5 ] "re"( _5 ),
                  [ a6 ] "re"( _6 ),
                  [ a7 ] "re"( _7 ),
                  [ a8 ] "re"( _8 ),
                  [ a9 ] "re"( _9 ),
                  [ a10 ] "re"( _10 )
                  : "memory", "cc" );
    return status;
}

NELUA_INLINE uint32_t syscall_11_stub( uint32_t id, uint64_t _1, uint64_t _2, uint64_t _3, uint64_t _4, uint64_t _5, uint64_t _6, uint64_t _7, uint64_t _8, uint64_t _9, uint64_t _10, uint64_t _11 )
{
    register uint64_t a1 asm( "r10" ) = _1;
    register uint64_t a3 asm( "r8" ) = _3;
    register uint64_t a4 asm( "r9" ) = _4;

    void* unused_output;
    register uint64_t unused_output2 asm( "r11" );

    uint32_t status;
    asm volatile( "sub $96, %%rsp\n"
                  "movq %[a5], 40(%%rsp)\n"
                  "movq %[a6], 48(%%rsp)\n"
                  "movq %[a7], 56(%%rsp)\n"
                  "movq %[a8], 64(%%rsp)\n"
                  "movq %[a9], 72(%%rsp)\n"
                  "movq %[a10], 80(%%rsp)\n"
                  "movq %[a11], 88(%%rsp)\n"
                  "syscall\n"
                  "add $96, %%rsp"
                  : "=a"( status ), "=r"( a1 ), "=d"( _2 ), "=r"( a3 ), "=r"( a4 ), "=c"( unused_output ), "=r"( unused_output2 )
                  : "a"( id ),
                  "r"( a1 ),
                  "d"( _2 ),
                  "r"( a3 ),
                  "r"( a4 ),
                  [ a5 ] "re"( _5 ),
                  [ a6 ] "re"( _6 ),
                  [ a7 ] "re"( _7 ),
                  [ a8 ] "re"( _8 ),
                  [ a9 ] "re"( _9 ),
                  [ a10 ] "re"( _10 ),
                  [ a11 ] "re"( _11 )
                  : "memory", "cc" );
    return status;
}

NELUA_INLINE uint32_t syscall_12_stub( uint32_t id, uint64_t _1, uint64_t _2, uint64_t _3, uint64_t _4, uint64_t _5, uint64_t _6, uint64_t _7, uint64_t _8, uint64_t _9, uint64_t _10, uint64_t _11, uint64_t _12 )
{
    register uint64_t a1 asm( "r10" ) = _1;
    register uint64_t a3 asm( "r8" ) = _3;
    register uint64_t a4 asm( "r9" ) = _4;

    void* unused_output;
    register uint64_t unused_output2 asm( "r11" );

    uint32_t status;
    asm volatile( "sub $112, %%rsp\n"
                  "movq %[a5], 40(%%rsp)\n"
                  "movq %[a6], 48(%%rsp)\n"
                  "movq %[a7], 56(%%rsp)\n"
                  "movq %[a8], 64(%%rsp)\n"
                  "movq %[a9], 72(%%rsp)\n"
                  "movq %[a10], 80(%%rsp)\n"
                  "movq %[a11], 88(%%rsp)\n"
                  "movq %[a12], 96(%%rsp)\n"
                  "syscall\n"
                  "add $112, %%rsp"
                  : "=a"( status ), "=r"( a1 ), "=d"( _2 ), "=r"( a3 ), "=r"( a4 ), "=c"( unused_output ), "=r"( unused_output2 )
                  : "a"( id ),
                  "r"( a1 ),
                  "d"( _2 ),
                  "r"( a3 ),
                  "r"( a4 ),
                  [ a5 ] "re"( _5 ),
                  [ a6 ] "re"( _6 ),
                  [ a7 ] "re"( _7 ),
                  [ a8 ] "re"( _8 ),
                  [ a9 ] "re"( _9 ),
                  [ a10 ] "re"( _10 ),
                  [ a11 ] "re"( _11 ),
                  [ a12 ] "re"( _12 )
                  : "memory", "cc" );
    return status;
}

NELUA_INLINE uint32_t syscall_13_stub( uint32_t id, uint64_t _1, uint64_t _2, uint64_t _3, uint64_t _4, uint64_t _5, uint64_t _6, uint64_t _7, uint64_t _8, uint64_t _9, uint64_t _10, uint64_t _11, uint64_t _12, uint64_t _13 )
{
    register uint64_t a1 asm( "r10" ) = _1;
    register uint64_t a3 asm( "r8" ) = _3;
    register uint64_t a4 asm( "r9" ) = _4;

    void* unused_output;
    register uint64_t unused_output2 asm( "r11" );

    uint32_t status;
    asm volatile( "sub $112, %%rsp\n"
                  "movq %[a5], 40(%%rsp)\n"
                  "movq %[a6], 48(%%rsp)\n"
                  "movq %[a7], 56(%%rsp)\n"
                  "movq %[a8], 64(%%rsp)\n"
                  "movq %[a9], 72(%%rsp)\n"
                  "movq %[a10], 80(%%rsp)\n"
                  "movq %[a11], 88(%%rsp)\n"
                  "movq %[a12], 96(%%rsp)\n"
                  "movq %[a13], 104(%%rsp)\n"
                  "syscall\n"
                  "add $112, %%rsp"
                  : "=a"( status ), "=r"( a1 ), "=d"( _2 ), "=r"( a3 ), "=r"( a4 ), "=c"( unused_output ), "=r"( unused_output2 )
                  : "a"( id ),
                  "r"( a1 ),
                  "d"( _2 ),
                  "r"( a3 ),
                  "r"( a4 ),
                  [ a5 ] "re"( _5 ),
                  [ a6 ] "re"( _6 ),
                  [ a7 ] "re"( _7 ),
                  [ a8 ] "re"( _8 ),
                  [ a9 ] "re"( _9 ),
                  [ a10 ] "re"( _10 ),
                  [ a11 ] "re"( _11 ),
                  [ a12 ] "re"( _12 ),
                  [ a13 ] "re"( _13 )
                  : "memory", "cc" );
    return status;
}


NELUA_INLINE uint64_t machine_Machine_handle_syscall( machine_Machine_ptr self, uint64_t code )
{
    switch( code )
    {
    case 10000:
    {
        self->running = false;
        self->exitcode = ( int64_t )( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ 10 ];
        break;
    }
    case 10001:
    {
        nelua_panic_string( ( ( nlstring )
        {
            ( uint8_t* )"aborted!", 8
        } ) );
        break;
    }
    case 10007:
    {
        void* dest = machine_Machine_getptr( self, ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ 10 ] );
        uint64_t c = ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ 11 ];
        uint64_t len = ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ 12 ];
        void* res = memset( dest, ( int )c, ( size_t )len );
        return ( uint64_t )res;
    }
    case 10101:
    {
        char* s = ( char* )machine_Machine_getptr( self, ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ 10 ] );
        nelua_print_1( s );
        break;
    }
    case 10102:
    {
        int64_t i = ( int64_t )( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ 10 ];
        nelua_print_2( i );
        break;
    }
    case 20000:
    {
        uint32_t id = ( uint32_t )( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ 27 ];
        return ( uint64_t )syscall_0_stub( id );
    }
    case 20001:
    {
        uint32_t id = ( uint32_t )( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ 27 ];
        uint64_t a1 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 10 ];
        return ( uint64_t )syscall_1_stub( id, a1 );
    }
    case 20002:
    {
        uint32_t id = ( uint32_t )( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ 27 ];
        uint64_t a1 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 10 ];
        uint64_t a2 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 11 ];
        return ( uint64_t )syscall_2_stub( id, a1, a2 );
    }
    case 20003:
    {
        uint32_t id = ( uint32_t )( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ 27 ];
        uint64_t a1 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 10 ];
        uint64_t a2 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 11 ];
        uint64_t a3 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 12 ];
        return ( uint64_t )syscall_3_stub( id, a1, a2, a3 );
    }
    case 20004:
    {
        uint32_t id = ( uint32_t )( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ 27 ];
        uint64_t a1 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 10 ];
        uint64_t a2 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 11 ];
        uint64_t a3 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 12 ];
        uint64_t a4 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 13 ];
        return ( uint64_t )syscall_4_stub( id, a1, a2, a3, a4 );
    }
    case 20005:
    {
        uint32_t id = ( uint32_t )( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ 27 ];
        uint64_t a1 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 10 ];
        uint64_t a2 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 11 ];
        uint64_t a3 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 12 ];
        uint64_t a4 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 13 ];
        uint64_t a5 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 14 ];
        return ( uint64_t )syscall_5_stub( id, a1, a2, a3, a4, a5 );
    }
    case 20006:
    {
        uint32_t id = ( uint32_t )( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ 27 ];
        uint64_t a1 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 10 ];
        uint64_t a2 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 11 ];
        uint64_t a3 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 12 ];
        uint64_t a4 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 13 ];
        uint64_t a5 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 14 ];
        uint64_t a6 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 15 ];
        return ( uint64_t )syscall_6_stub( id, a1, a2, a3, a4, a5, a6 );
    }
    case 20007:
    {
        uint32_t id = ( uint32_t )( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ 27 ];
        uint64_t a1 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 10 ];
        uint64_t a2 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 11 ];
        uint64_t a3 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 12 ];
        uint64_t a4 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 13 ];
        uint64_t a5 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 14 ];
        uint64_t a6 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 15 ];
        uint64_t a7 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 16 ];
        return ( uint64_t )syscall_7_stub( id, a1, a2, a3, a4, a5, a6, a7 );
    }
    case 20008:
    {
        uint32_t id = ( uint32_t )( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ 27 ];
        uint64_t a1 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 10 ];
        uint64_t a2 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 11 ];
        uint64_t a3 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 12 ];
        uint64_t a4 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 13 ];
        uint64_t a5 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 14 ];
        uint64_t a6 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 15 ];
        uint64_t a7 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 16 ];
        uint64_t a8 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 17 ];
        return ( uint64_t )syscall_8_stub( id, a1, a2, a3, a4, a5, a6, a7, a8 );
    }
    case 20009:
    {
        uint32_t id = ( uint32_t )( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ 27 ];
        uint64_t a1 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 10 ];
        uint64_t a2 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 11 ];
        uint64_t a3 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 12 ];
        uint64_t a4 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 13 ];
        uint64_t a5 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 14 ];
        uint64_t a6 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 15 ];
        uint64_t a7 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 16 ];
        uint64_t a8 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 17 ];
        uint64_t a9 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 18 ];
        return ( uint64_t )syscall_9_stub( id, a1, a2, a3, a4, a5, a6, a7, a8, a9 );
    }
    case 20010:
    {
        uint32_t id = ( uint32_t )( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ 27 ];
        uint64_t a1 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 10 ];
        uint64_t a2 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 11 ];
        uint64_t a3 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 12 ];
        uint64_t a4 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 13 ];
        uint64_t a5 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 14 ];
        uint64_t a6 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 15 ];
        uint64_t a7 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 16 ];
        uint64_t a8 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 17 ];
        uint64_t a9 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 18 ];
        uint64_t a10 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 19 ];
        return ( uint64_t )syscall_10_stub( id, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 );
    }
    case 20011:
    {
        uint32_t id = ( uint32_t )( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ 27 ];
        uint64_t a1 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 10 ];
        uint64_t a2 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 11 ];
        uint64_t a3 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 12 ];
        uint64_t a4 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 13 ];
        uint64_t a5 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 14 ];
        uint64_t a6 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 15 ];
        uint64_t a7 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 16 ];
        uint64_t a8 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 17 ];
        uint64_t a9 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 18 ];
        uint64_t a10 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 19 ];
        uint64_t a11 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 20 ];
        return ( uint64_t )syscall_11_stub( id, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 );
    }
    case 20012:
    {
        uint32_t id = ( uint32_t )( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ 27 ];
        uint64_t a1 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 10 ];
        uint64_t a2 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 11 ];
        uint64_t a3 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 12 ];
        uint64_t a4 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 13 ];
        uint64_t a5 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 14 ];
        uint64_t a6 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 15 ];
        uint64_t a7 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 16 ];
        uint64_t a8 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 17 ];
        uint64_t a9 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 18 ];
        uint64_t a10 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 19 ];
        uint64_t a11 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 20 ];
        uint64_t a12 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 21 ];
        return ( uint64_t )syscall_12_stub( id, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 );
    }
    case 20013:
    {
        uint32_t id = ( uint32_t )( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ 27 ];
        uint64_t a1 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 10 ];
        uint64_t a2 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 11 ];
        uint64_t a3 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 12 ];
        uint64_t a4 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 13 ];
        uint64_t a5 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 14 ];
        uint64_t a6 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 15 ];
        uint64_t a7 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 16 ];
        uint64_t a8 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 17 ];
        uint64_t a9 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 18 ];
        uint64_t a10 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 19 ];
        uint64_t a11 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 20 ];
        uint64_t a12 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 21 ];
        uint64_t a13 = ( ( nluint64_arr32_cast* )&self->regs )->a.v[ 22 ];
        return ( uint64_t )syscall_13_stub( id, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 );
    }
    default:
    {
        printf( "code: %d\n", code );
        nelua_panic_string( ( ( nlstring )
        {
            ( uint8_t* )"illegal system call", 19
        } ) );
        break;
    }
    }
    return 0U;
}
int64_t nelua_shl_nlint64( int64_t a, int64_t b )
{
    if( NELUA_LIKELY( b >= 0 && b < 64 ) )
    {
        return ( ( uint64_t )a ) << b;
    }
    else if( NELUA_UNLIKELY( b < 0 && b > -64 ) )
    {
        return ( uint64_t )a >> -b;
    }
    else
    {
        return 0;
    }
}
int64_t nelua_shr_nlint64( int64_t a, int64_t b )
{
    if( NELUA_LIKELY( b >= 0 && b < 64 ) )
    {
        return ( uint64_t )a >> b;
    }
    else if( NELUA_UNLIKELY( b < 0 && b > -64 ) )
    {
        return ( uint64_t )a << -b;
    }
    else
    {
        return 0;
    }
}
int64_t nelua_asr_nlint64( int64_t a, int64_t b )
{
    if( NELUA_LIKELY( b >= 0 && b < 64 ) )
    {
        return a >> b;
    }
    else if( NELUA_UNLIKELY( b >= 64 ) )
    {
        return a < 0 ? -1 : 0;
    }
    else if( NELUA_UNLIKELY( b < 0 && b > -64 ) )
    {
        return a << -b;
    }
    else
    {
        return 0;
    }
}
__int128 nelua_shr_nlint128( __int128 a, __int128 b )
{
    if( NELUA_LIKELY( b >= 0 && b < 128 ) )
    {
        return ( unsigned __int128 )a >> b;
    }
    else if( NELUA_UNLIKELY( b < 0 && b > -128 ) )
    {
        return ( unsigned __int128 )a << -b;
    }
    else
    {
        return 0;
    }
}
void machine_Machine_execute( machine_Machine_ptr self, uint32_t inst )
{
    uint32_t opcode = ( ( inst >> 0 ) & 127 );
    uint32_t rd = ( ( inst >> 7 ) & 31 );
    uint32_t rs1 = ( ( inst >> 15 ) & 31 );
    uint32_t rs2 = ( ( inst >> 20 ) & 31 );
    switch( opcode )
    {
    case 0x3:
    {
        uint32_t funct3 = ( ( inst >> 12 ) & 7 );
        int64_t imm = ( int64_t )( ( ( int32_t )( ( uint32_t )( int32_t )( ( inst >> 20 ) & 4095 ) << 20 ) ) >> 20 );
        uint64_t addr = ( ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rs1 ] + ( uint64_t )imm );
        int64_t val;
        switch( funct3 )
        {
        case 0x0:
        {
            val = ( int64_t )machine_Machine_read_1( self, NELUA_NIL, addr );
            break;
        }
        case 0x1:
        {
            val = ( int64_t )machine_Machine_read_2( self, NELUA_NIL, addr );
            break;
        }
        case 0x2:
        {
            val = ( int64_t )machine_Machine_read_3( self, NELUA_NIL, addr );
            break;
        }
        case 0x3:
        {
            val = machine_Machine_read_4( self, NELUA_NIL, addr );
            break;
        }
        case 0x4:
        {
            val = ( int64_t )machine_Machine_read_5( self, NELUA_NIL, addr );
            break;
        }
        case 0x5:
        {
            val = ( int64_t )machine_Machine_read_6( self, NELUA_NIL, addr );
            break;
        }
        case 0x6:
        {
            val = ( int64_t )machine_Machine_read_7( self, NELUA_NIL, addr );
            break;
        }
        default:
        {
            nelua_panic_string( ( ( nlstring )
            {
                ( uint8_t* )"illegal load instruction", 24
            } ) );
            break;
        }
        }
        if( NELUA_LIKELY( ( rd != 0 ) ) )
        {
            ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rd ] = ( uint64_t )val;
        }
        break;
    }
    case 0x23:
    {
        uint32_t funct3 = ( ( inst >> 12 ) & 7 );
        int64_t imm = ( int64_t )( ( ( int32_t )( ( uint32_t )( int32_t )( ( ( inst >> 20 ) & 4064 ) | ( ( inst >> 7 ) & 31 ) ) << 20 ) ) >> 20 );
        uint64_t addr = ( ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rs1 ] + ( uint64_t )imm );
        uint64_t val = ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rs2 ];
        switch( funct3 )
        {
        case 0x0:
        {
            machine_Machine_write_1( self, addr, ( uint8_t )val );
            break;
        }
        case 0x1:
        {
            machine_Machine_write_2( self, addr, ( uint16_t )val );
            break;
        }
        case 0x2:
        {
            machine_Machine_write_3( self, addr, ( uint32_t )val );
            break;
        }
        case 0x3:
        {
            machine_Machine_write_4( self, addr, val );
            break;
        }
        default:
        {
            nelua_panic_string( ( ( nlstring )
            {
                ( uint8_t* )"illegal store instruction", 25
            } ) );
            break;
        }
        }
        break;
    }
    case 0x13:
    {
        uint32_t funct3 = ( ( inst >> 12 ) & 7 );
        int64_t imm = ( int64_t )( ( ( int32_t )( ( uint32_t )( int32_t )( ( inst >> 20 ) & 4095 ) << 20 ) ) >> 20 );
        uint32_t shamt = ( ( inst >> 20 ) & 63 );
        int64_t val = ( int64_t )( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rs1 ];
        switch( funct3 )
        {
        case 0x0:
        {
            val = ( val + imm );
            break;
        }
        case 0x1:
        {
            val = nelua_shl_nlint64( val, shamt );
            break;
        }
        case 0x2:
        {
            if( ( val < imm ) )
            {
                val = 1;
            }
            else
            {
                val = 0;
            }
            break;
        }
        case 0x3:
        {
            if( ( ( uint64_t )val < ( uint64_t )imm ) )
            {
                val = 1;
            }
            else
            {
                val = 0;
            }
            break;
        }
        case 0x4:
        {
            val = ( val ^ imm );
            break;
        }
        case 0x5:
        {
            uint32_t funct6 = ( ( inst >> 26 ) & 63 );
            switch( ( funct6 >> 4 ) )
            {
            case 0x0:
            {
                val = nelua_shr_nlint64( val, shamt );
                break;
            }
            case 0x1:
            {
                val = nelua_asr_nlint64( val, shamt );
                break;
            }
            default:
            {
                nelua_panic_string( ( ( nlstring )
                {
                    ( uint8_t* )"illegal op-imm shift instruction", 32
                } ) );
                break;
            }
            }
            break;
        }
        case 0x6:
        {
            val = ( val | imm );
            break;
        }
        case 0x7:
        {
            val = ( val & imm );
            break;
        }
        default:
        {
            nelua_panic_string( ( ( nlstring )
            {
                ( uint8_t* )"illegal op-imm instruction", 26
            } ) );
            break;
        }
        }
        if( NELUA_LIKELY( ( rd != 0 ) ) )
        {
            ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rd ] = ( uint64_t )val;
        }
        break;
    }
    case 0x1b:
    {
        uint32_t funct3 = ( ( inst >> 12 ) & 7 );
        int64_t imm = ( int64_t )( ( ( int32_t )( ( uint32_t )( int32_t )( ( inst >> 20 ) & 4095 ) << 20 ) ) >> 20 );
        int64_t val = ( int64_t )( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rs1 ];
        switch( funct3 )
        {
        case 0x0:
        {
            val = ( int64_t )( int32_t )( val + imm );
            break;
        }
        case 0x1:
        {
            val = ( int64_t )( int32_t )nelua_shl_nlint64( val, imm );
            break;
        }
        case 0x5:
        {
            uint32_t shamt = rs2;
            uint32_t funct7 = ( ( inst >> 25 ) & 127 );
            switch( ( funct7 >> 5 ) )
            {
            case 0x0:
            {
                val = ( int64_t )( int32_t )nelua_shr_nlint64( val, shamt );
                break;
            }
            case 0x1:
            {
                val = ( int64_t )( int32_t )nelua_asr_nlint64( val, shamt );
                break;
            }
            default:
            {
                nelua_panic_string( ( ( nlstring )
                {
                    ( uint8_t* )"illegal op-imm-32 shift instruction", 35
                } ) );
                break;
            }
            }
            break;
        }
        default:
        {
            nelua_panic_string( ( ( nlstring )
            {
                ( uint8_t* )"illegal op-imm-32 instruction", 29
            } ) );
            break;
        }
        }
        if( NELUA_LIKELY( ( rd != 0 ) ) )
        {
            ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rd ] = ( uint64_t )val;
        }
        break;
    }
    case 0x33:
    {
        uint32_t funct3 = ( ( inst >> 12 ) & 7 );
        uint32_t funct7 = ( ( inst >> 25 ) & 127 );
        int64_t val1 = ( int64_t )( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rs1 ];
        int64_t val2 = ( int64_t )( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rs2 ];
        int64_t val;
        switch( ( ( funct7 << 3 ) | funct3 ) )
        {
        case 0x0:
        {
            val = ( val1 + val2 );
            break;
        }
        case 0x100:
        {
            val = ( val1 - val2 );
            break;
        }
        case 0x1:
        {
            val = nelua_shl_nlint64( val1, ( val2 & 0x1f ) );
            break;
        }
        case 0x2:
        {
            if( ( val1 < val2 ) )
            {
                val = 1;
            }
            else
            {
                val = 0;
            }
            break;
        }
        case 0x3:
        {
            if( ( ( uint64_t )val1 < ( uint64_t )val2 ) )
            {
                val = 1;
            }
            else
            {
                val = 0;
            }
            break;
        }
        case 0x4:
        {
            val = ( val1 ^ val2 );
            break;
        }
        case 0x5:
        {
            val = nelua_shr_nlint64( val1, ( val2 & 0x1f ) );
            break;
        }
        case 0x105:
        {
            val = nelua_asr_nlint64( val1, ( val2 & 0x1f ) );
            break;
        }
        case 0x6:
        {
            val = ( val1 | val2 );
            break;
        }
        case 0x7:
        {
            val = ( val1 & val2 );
            break;
        }
        case 0x8:
        {
            val = ( val1 * val2 );
            break;
        }
        case 0x9:
        {
            val = ( int64_t )( uint64_t )nelua_shr_nlint128( ( ( __int128 )val1 * ( __int128 )val2 ), 64 );
            break;
        }
        case 0xa:
        {
            val = ( int64_t )( uint64_t )nelua_shr_nlint128( ( ( __int128 )val1 * ( __int128 )( uint64_t )val2 ), 64 );
            break;
        }
        case 0xb:
        {
            val = ( int64_t )( uint64_t )nelua_shr_nlint128( ( ( __int128 )( uint64_t )val1 * ( __int128 )( uint64_t )val2 ), 64 );
            break;
        }
        case 0xc:
        {
            int64_t dividend = val1;
            int64_t divisor = val2;
            if( NELUA_UNLIKELY( ( ( dividend == ( -9223372036854775807LL - 1 ) ) && ( divisor == -1 ) ) ) )
            {
                val = ( -9223372036854775807LL - 1 );
            }
            else if( NELUA_UNLIKELY( ( divisor == 0 ) ) )
            {
                val = -1;
            }
            else
            {
                val = ( dividend / divisor );
            }
            break;
        }
        case 0xd:
        {
            uint64_t dividend = ( uint64_t )val1;
            uint64_t divisor = ( uint64_t )val2;
            if( NELUA_UNLIKELY( ( divisor == 0 ) ) )
            {
                val = -1;
            }
            else
            {
                val = ( int64_t )( dividend / divisor );
            }
            break;
        }
        case 0xe:
        {
            int64_t dividend = val1;
            int64_t divisor = val2;
            if( NELUA_UNLIKELY( ( ( dividend == ( -9223372036854775807LL - 1 ) ) && ( divisor == -1 ) ) ) )
            {
                val = 0;
            }
            else if( NELUA_UNLIKELY( ( divisor == 0 ) ) )
            {
                val = dividend;
            }
            else
            {
                val = ( dividend % divisor );
            }
            break;
        }
        case 0xf:
        {
            uint64_t dividend = ( uint64_t )val1;
            uint64_t divisor = ( uint64_t )val2;
            if( NELUA_UNLIKELY( ( divisor == 0 ) ) )
            {
                val = ( int64_t )dividend;
            }
            else
            {
                val = ( int64_t )( dividend % divisor );
            }
            break;
        }
        default:
        {
            nelua_panic_string( ( ( nlstring )
            {
                ( uint8_t* )"illegal op instruction", 22
            } ) );
            break;
        }
        }
        if( NELUA_LIKELY( ( rd != 0 ) ) )
        {
            ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rd ] = ( uint64_t )val;
        }
        break;
    }
    case 0x3b:
    {
        uint32_t funct3 = ( ( inst >> 12 ) & 7 );
        uint32_t funct7 = ( ( inst >> 25 ) & 127 );
        int64_t val1 = ( int64_t )( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rs1 ];
        int64_t val2 = ( int64_t )( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rs2 ];
        int64_t val;
        switch( ( ( funct7 << 3 ) | funct3 ) )
        {
        case 0x0:
        {
            val = ( int64_t )( int32_t )( val1 + val2 );
            break;
        }
        case 0x100:
        {
            val = ( int64_t )( int32_t )( val1 - val2 );
            break;
        }
        case 0x1:
        {
            val = ( int64_t )( int32_t )nelua_shl_nlint64( val1, ( val2 & 0x1f ) );
            break;
        }
        case 0x5:
        {
            val = ( int64_t )( int32_t )nelua_shr_nlint64( val1, ( val2 & 0x1f ) );
            break;
        }
        case 0x105:
        {
            val = ( int64_t )( int32_t )nelua_asr_nlint64( val1, ( val2 & 0x1f ) );
            break;
        }
        case 0x8:
        {
            val = ( int64_t )( ( int32_t )val1 * ( int32_t )val2 );
            break;
        }
        case 0xc:
        {
            int32_t dividend = ( int32_t )val1;
            int32_t divisor = ( int32_t )val2;
            if( NELUA_UNLIKELY( ( ( dividend == ( -2147483647 - 1 ) ) && ( divisor == -1 ) ) ) )
            {
                val = -2147483648LL;
            }
            else if( NELUA_UNLIKELY( ( divisor == 0 ) ) )
            {
                val = -1;
            }
            else
            {
                val = ( int64_t )( dividend / divisor );
            }
            break;
        }
        case 0xd:
        {
            uint32_t dividend = ( uint32_t )val1;
            uint32_t divisor = ( uint32_t )val2;
            if( NELUA_UNLIKELY( ( divisor == 0 ) ) )
            {
                val = -1;
            }
            else
            {
                val = ( int64_t )( int32_t )( dividend / divisor );
            }
            break;
        }
        case 0xe:
        {
            int32_t dividend = ( int32_t )val1;
            int32_t divisor = ( int32_t )val2;
            if( NELUA_UNLIKELY( ( ( dividend == ( -2147483647 - 1 ) ) && ( divisor == -1 ) ) ) )
            {
                val = 0;
            }
            else if( NELUA_UNLIKELY( ( divisor == 0 ) ) )
            {
                val = ( int64_t )dividend;
            }
            else
            {
                val = ( int64_t )( dividend % divisor );
            }
            break;
        }
        case 0xf:
        {
            uint32_t dividend = ( uint32_t )val1;
            uint32_t divisor = ( uint32_t )val2;
            if( NELUA_UNLIKELY( ( divisor == 0 ) ) )
            {
                val = ( int64_t )( int32_t )dividend;
            }
            else
            {
                val = ( int64_t )( int32_t )( dividend % divisor );
            }
            break;
        }
        default:
        {
            nelua_panic_string( ( ( nlstring )
            {
                ( uint8_t* )"illegal op-32 instruction", 25
            } ) );
            break;
        }
        }
        if( NELUA_LIKELY( ( rd != 0 ) ) )
        {
            ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rd ] = ( uint64_t )val;
        }
        break;
    }
    case 0x37:
    {
        int64_t imm = ( int64_t )( ( ( int32_t )( ( uint32_t )( int32_t )( ( inst << 0 ) & 4294963200LL ) << 0 ) ) >> 0 );
        if( NELUA_LIKELY( ( rd != 0 ) ) )
        {
            ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rd ] = ( uint64_t )imm;
        }
        break;
    }
    case 0x17:
    {
        int64_t imm = ( int64_t )( ( ( int32_t )( ( uint32_t )( int32_t )( ( inst << 0 ) & 4294963200LL ) << 0 ) ) >> 0 );
        if( NELUA_LIKELY( ( rd != 0 ) ) )
        {
            ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rd ] = ( uint64_t )( self->pc + imm );
        }
        break;
    }
    case 0x6f:
    {
        int64_t imm = ( int64_t )( ( ( int32_t )( ( uint32_t )( int32_t )( ( ( ( ( inst >> 11 ) & 1048576 ) | ( ( inst >> 20 ) & 2046 ) ) | ( ( inst >> 9 ) & 2048 ) ) | ( ( inst << 0 ) & 1044480 ) ) << 11 ) ) >> 11 );
        if( NELUA_LIKELY( ( rd != 0 ) ) )
        {
            ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rd ] = ( uint64_t )( self->pc + 4 );
        }
        self->pc = ( self->pc + imm );
        return;
    }
    case 0x67:
    {
        int64_t imm = ( int64_t )( ( ( int32_t )( ( uint32_t )( int32_t )( ( inst >> 20 ) & 4095 ) << 20 ) ) >> 20 );
        int64_t pc = ( self->pc + 4 );
        self->pc = ( ( int64_t )( ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rs1 ] + imm ) & -2 );
        if( NELUA_UNLIKELY( ( rd != 0 ) ) )
        {
            ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rd ] = ( uint64_t )pc;
        }
        return;
    }
    case 0x63:
    {
        uint32_t funct3 = ( ( inst >> 12 ) & 7 );
        int64_t imm = ( int64_t )( ( ( int32_t )( ( uint32_t )( int32_t )( ( ( ( ( inst >> 19 ) & 4096 ) | ( ( inst >> 20 ) & 2016 ) ) | ( ( inst >> 7 ) & 30 ) ) | ( ( inst << 4 ) & 2048 ) ) << 19 ) ) >> 19 );
        uint64_t val1 = ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rs1 ];
        uint64_t val2 = ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rs2 ];
        bool cond;
        switch( funct3 )
        {
        case 0x0:
        {
            cond = ( val1 == val2 );
            break;
        }
        case 0x1:
        {
            cond = ( val1 != val2 );
            break;
        }
        case 0x4:
        {
            cond = ( ( int64_t )val1 < ( int64_t )val2 );
            break;
        }
        case 0x5:
        {
            cond = ( ( int64_t )val1 >= ( int64_t )val2 );
            break;
        }
        case 0x6:
        {
            cond = ( val1 < val2 );
            break;
        }
        case 0x7:
        {
            cond = ( val1 >= val2 );
            break;
        }
        default:
        {
            nelua_panic_string( ( ( nlstring )
            {
                ( uint8_t* )"illegal branch instruction", 26
            } ) );
            break;
        }
        }
        if( cond )
        {
            self->pc = ( self->pc + imm );
            return;
        }
        break;
    }
    case 0xf:
    {
        break;
    }
    case 0x73:
    {
        uint32_t funct11 = ( ( inst >> 20 ) & 4095 );
        switch( funct11 )
        {
        case 0x0:
        {
            uint64_t code = ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ 26 ];
            ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ 10 ] = machine_Machine_handle_syscall( self, code );
            break;
        }
        case 0x1:
        {
            self->exitcode = -1;
            self->running = false;
            break;
        }
        default:
        {
            nelua_panic_string( ( ( nlstring )
            {
                ( uint8_t* )"illegal system instruction", 26
            } ) );
            break;
        }
        }
        break;
    }
    default:
    {
        printf( "opcode: %x\n", opcode );
        nelua_panic_string( ( ( nlstring )
        {
            ( uint8_t* )"illegal instruction", 19
        } ) );
        break;
    }
    }
    self->pc = ( self->pc + 4 );
}
void machine_Machine_run( machine_Machine_ptr self )
{
    self->running = true;
    while( NELUA_LIKELY( self->running ) )
    {
        uint32_t inst = machine_Machine_fetch( self );
        machine_Machine_execute( self, inst );
    }
}
void nelua_print_3( nlstring a1 )
{
    if( a1.size > 0 )
    {
        fwrite( a1.data, 1, a1.size, stdout );
    }
    fputs( "\n", stdout );
    fflush( stdout );
}
nlstring nelua_cstring2string( const char* s )
{
    if( s == NULL )
    {
        return ( nlstring )
        {
            0
        };
    }
    uintptr_t size = strlen( s );
    if( size == 0 )
    {
        return ( nlstring )
        {
            0
        };
    }
    return ( nlstring )
    {
        ( uint8_t* )s, size
    };
}
int nelua_main( int argc, char** argv )
{
    nelua_argc = argc;
    nelua_argv = argv;
    if( ( nelua_argc != 2 ) )
    {
        nelua_print_3( ( ( nlstring )
        {
            ( uint8_t* )"please supply a RV64I program to run!", 37
        } ) );
        exit( 1 );
    }
    riscvm_filename = nelua_argv[ 1 ];
    machine_Machine_loadfile( ( &riscvm_machine ), nelua_cstring2string( riscvm_filename ) );
    machine_Machine_run( ( &riscvm_machine ) );
    exit( ( int )riscvm_machine.exitcode );
    return 0;
}
int main( int argc, char** argv )
{
    return nelua_main( argc, argv );
}
